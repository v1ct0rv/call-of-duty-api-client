const {
  MongoClient
} = require("mongodb")
const moment = require('moment')

const TrackedGamersService = require("../services/trackedGamersService");
const PlayerMatchesService = require("../services/playerMatchesService")
const RebirthStatsService = require("../services/rebirthStatsService")
const BrStatsService = require("../services/brStatsService");

const aggregateJob = async function () {
  // Create a new MongoClient
  const client = new MongoClient(process.env.MONGO_DB_URI);

  try {
    // Connect the client to the server
    await client.connect();

    // Create the DB if not exists
    const database = client.db('cod-stats')

    const trackedGamersService = new TrackedGamersService(client, database)
    await trackedGamersService.init()

    const playerMatchesService = new PlayerMatchesService(client, database, null, trackedGamersService)
    await playerMatchesService.init()

    const rebirthStatsService = new RebirthStatsService(client, database)
    await rebirthStatsService.init()

    const brStatsService = new BrStatsService(client, database, null)
    await brStatsService.init()

     const gamers = await trackedGamersService.getAll()

    console.time('AggregateStats')
    for (const gamer of gamers) {
      let gamertag = gamer.gamertag
      let platform = gamer.platform
      let date = getCurrentDateWithoutTime()
      console.log(`[${new Date().toISOString()}] Processing (Aggregate) Stats for '${gamertag}' and platform '${platform}'...`)

      console.log(`Getting maxKills and longestStreaks in a BR win...`)

      // TODO update brstats with maxKills and longestStreaks in a BR win.

      //   db.getCollection('playermatches').aggregate( [
      //    // Stage 1: Filter All Moga BR Wins
      //    {
      //       $match: {"platform" : "battle", "username" : "elmogo06#1516", "playerStats.teamPlacement": 1, "mode": {$in: [ "br_brquads","br_brtrios","br_brduos","br_brsolos", "br_brsolo", "br_vg_royale_quads", "br_vg_royale_trios", "br_vg_royale_duos", "br_vg_royale_solos", "br_vg_royale_solo", "br_br_real", "br_dbd_dbd", "br_vov_op_flash", "br_brz_brquads", "br_brz_brtrios", "br_brz_brduos", "br_brbbquad", "br_brbbtrio", "br_brbbduo", "br_brbbsolo", "br_br_quads", "br_brhwnquad", "br_brhwntrios", "br_brduohwn", "br_brsolohwn", "br_buy_back_quads", "br_buy_back_trios", "br_buy_back_duos", "br_buy_back_solo", "br_mendota_playlist_wz330/op_mon" ]}}
      //    },
      //    // Stage 2: Sort by Kills desc
      //    {
      //        $sort: {
      //          "playerStats.kills": -1
      //        }
      //    },
      //    // Stage 3: Group remaining documents and calculate total wins and maxKills
      //    {
      //       $group: { _id: "", wins: {$sum:1}, maxKills: { $max: "$playerStats.kills" }, longestStreak: { $max: "$playerStats.longestStreak" }, "doc": {
      //                 "$first": "$$ROOT"
      //             } }
      //    }
      // ] )

      console.log(`Getting Last Win data...`)

      // Set last win data
      console.time(`getLastWin ${gamertag}`)
      const lastWin = await playerMatchesService.getLastWinMatch(gamertag, platform)
      console.timeEnd(`getLastWin ${gamertag}`)

      if(lastWin) {
        const lastWinDate = moment.unix(lastWin.utcStartSeconds)
        console.log(`[${new Date().toISOString()}] ${gamertag} last win match id: ${lastWin.matchID} on ${lastWinDate.utcOffset(-300).format('YYYY-MM-DD hh:mm:ss')}`)
        lastWinObj = {
          matchID: lastWin.matchID,
          date: lastWinDate.toDate(),
          utcStartSeconds: lastWin.utcStartSeconds,
          utcEndSeconds: lastWin.utcEndSeconds,
          playerStats: lastWin.playerStats,
        }

        // Save
        await brStatsService.saveLastWin(gamertag, platform, date, lastWinObj)
      }

      console.log(`Getting rebirth stats for '${gamertag}' and platform '${platform}'...`)
      const rebithStats = await playerMatchesService.getRebirthStats(gamertag, platform)
      
      if(rebithStats) {
        // delete _id it should be autogenerated.
        delete rebithStats._id;

        rebithStats.username = gamertag
        rebithStats.platform = platform
        rebithStats.date = date
        rebithStats.kdRatio = rebithStats.kills/rebithStats.deaths
        //rebithStats.kdRatio = Math.round(((rebithStats.kills/rebithStats.deaths) + Number.EPSILON) * 100) / 100

        // Custom Stats
        rebithStats.killsPerGame = rebithStats.kills/rebithStats.gamesPlayed
        rebithStats.killsPerMin = rebithStats.kills/(rebithStats.timePlayed / 60)
        
        console.log(`Getting rebirth win stats for '${gamertag}' and platform '${platform}'...`)
        const rebithWinStats = await playerMatchesService.getRebirthWinStats(gamertag, platform)

        if(rebithWinStats && rebithWinStats.lastWin) {
          const lastWinDate = moment.unix(rebithWinStats.lastWin.utcStartSeconds)
          console.log(`[${new Date().toISOString()}] ${gamertag} rebirth last win match id: ${rebithWinStats.lastWin.matchID} on ${lastWinDate.utcOffset(-300).format('YYYY-MM-DD hh:mm:ss')}`)
          rebithStats.wins = rebithWinStats.wins
          rebithStats.maxKillsWin = rebithWinStats.maxKillsWin
          rebithStats.longestStreakWin = rebithWinStats.longestStreakWin
          rebithStats.lastWin = {
            matchID: rebithWinStats.lastWin.matchID,
            date: lastWinDate.toDate(),
            utcStartSeconds: rebithWinStats.lastWin.utcStartSeconds,
            utcEndSeconds: rebithWinStats.lastWin.utcEndSeconds,
            playerStats: rebithWinStats.lastWin.playerStats,
          }

          // Custom Stats
          rebithStats.winsPercent = ((rebithStats.wins*100)/rebithStats.gamesPlayed)
          rebithStats.gamesPerWin = rebithStats.gamesPlayed/rebithStats.wins
        }

        // console.log(`[${new Date().toISOString()}] ${gamertag} rebirth stats:`)
        // console.dir(rebithStats)
        await rebirthStatsService.add(rebithStats)
      } else {
        console.log(`[${new Date().toISOString()}] ${gamertag} has not rebirth stats`)
      }
    }
    console.timeEnd('AggregateStats')
  } catch (Error) {
      //Handle Exception
      console.error(Error)
    } finally {
      // Ensures that the client will close when you finish/error
      await client.close();
    }
}

function getCurrentDateWithoutTime() {
  return getDateWithoutTime(new Date())
}

function getDateWithoutTime(dateTime) {
  var date = new Date(dateTime.getTime())
  date.setHours(0, 0, 0, 0)
  return date
}



module.exports = aggregateJob